# Основна ідея цього коду - демонстрація того, як можна створити
# контекстний менеджер за допомогою класу або з допомогою генератора
# (з декоратором @contextmanager).
# Це корисно для автоматичного управління ресурсами, такими як відкриття
# та закриття файлів, з'єднань тощо.

# Імпортуємо декоратор contextmanager з модуля contextlib,
# який дозволяє створювати контекстні менеджери з допомогою генераторів
from contextlib import contextmanager


class MyContext:
    # Цей клас - приклад простого контекстного менеджера, але його методи закоментовані.

    # def __enter__(self):
    #     # Метод, який виконується при вході в контекст
    #     print("Entering the context")
    #     return self

    # def __exit__(self, *args, **kwargs):
    #     # Метод, який виконується при виході з контексту
    #     print("Exiting")

    def foo(self):
        # Довільний метод цього класу
        print("I am foo")


# Декоратор для створення контекстного менеджера з допомогою генератора
@contextmanager
def managed_resource(*args, **kwds):
    # Ініціалізація ресурсу
    print("Inside init")
    try:
        # Виведення значення, яке буде доступне всередині контекстного блоку
        yield "As value"
    finally:
        # Звільнення ресурсу після завершення роботи контекстного блоку
        print("Exiting")


# Використання генераторного контекстного менеджера
with managed_resource() as value:
    # Виведення значення, яке було отримано з генератора
    print(value)

# Закоментовані приклади використання класу як контекстного
# менеджера та звичайного об'єкта:
# with MyContext() as context:
#     context.foo()

# context = MyContext()
# context.foo()
